import { EventEmitter } from 'events';
import { GraphQLSchema, GraphQLError, validate, execute, parse, specifiedRules, OperationDefinition, Field } from 'graphql';
import { getArgumentValues } from 'graphql/execution/values';

import { subscriptionHasSingleRootField } from './validation';

class SubscriptionManager {

	constructor(options) {
		this.pubsub = options.pubsub;
		this.schema = options.schema;
		this.setupFunctions = options.setupFunctions || {};
		this.subscriptions = {};
		this.maxSubscriptionId = 0;
	}

	publish(triggerName, payload) {
		this.pubsub.publish(triggerName, payload);
	}

	subscribe(options) {

		// 1. validate the query, operationName and variables
		const parsedQuery = parse(options.query);
		const errors = validate(this.schema, parsedQuery, [...specifiedRules, subscriptionHasSingleRootField]);

		// TODO: validate that all variables have been passed (and are of correct type)?
		if (errors.length) {
			// this error kills the subscription, so we throw it.
			return Promise.reject < number > new ValidationError(errors);
		}

		let args = {};

		// operationName is the name of the only root field in the subscription document
		let subscriptionName = '';
		parsedQuery.definitions.forEach(definition => {
			if (definition.kind === 'OperationDefinition') {
				// only one root field is allowed on subscription. No fragments for now.
				const rootField = definition.selectionSet.selections[0];
				subscriptionName = rootField.name.value;

				const fields = this.schema.getSubscriptionType().getFields();
				args = getArgumentValues(fields[subscriptionName], rootField, options.variables);
			}
		});

		let triggerMap;

		if (this.setupFunctions[subscriptionName]) {
			triggerMap = this.setupFunctions[subscriptionName](options, args, subscriptionName);
		} else {
			// if not provided, the triggerName will be the subscriptionName, The trigger will not have any
			// options and rely on defaults that are set later.
			triggerMap = { [subscriptionName]: {} };
		}

		const externalSubscriptionId = this.maxSubscriptionId++;
		this.subscriptions[externalSubscriptionId] = [];
		const subscriptionPromises = [];
		Object.keys(triggerMap).forEach(triggerName => {
			// Deconstruct the trigger options and set any defaults
			const {
				channelOptions = {},
				filter = () => true // Let all messages through by default.
			} = triggerMap[triggerName];

			// 2. generate the handler function
			//
			// rootValue is the payload sent by the event emitter / trigger by
			// convention this is the value returned from the mutation
			// resolver
			const onMessage = rootValue => {
				return Promise.resolve().then(() => {
					if (typeof options.context === 'function') {
						return options.context();
					}
					return options.context;
				}).then(context => {
					return Promise.all([context, filter(rootValue, context)]);
				}).then(([context, doExecute]) => {
					if (!doExecute) {
						return;
					}
					execute(this.schema, parsedQuery, rootValue, context, options.variables, options.operationName).then(data => {
						return options.callback(data.errors, data);
					});
				}).catch(error => {
					options.callback(error);
				});
			};

			// 3. subscribe and keep the subscription id
			subscriptionPromises.push(this.pubsub.subscribe(triggerName, onMessage, channelOptions).then(id => this.subscriptions[externalSubscriptionId].push(id)));
		});

		// Resolve the promise with external sub id only after all subscriptions completed
		return Promise.all(subscriptionPromises).then(() => externalSubscriptionId);
	}

	unsubscribe(subId) {
		// pass the subId right through to pubsub. Do nothing else.
		this.subscriptions[subId].forEach(internalId => {
			this.pubsub.unsubscribe(internalId);
		});
		delete this.subscriptions[subId];
	}
};

export default SubscriptionManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsIkdyYXBoUUxTY2hlbWEiLCJHcmFwaFFMRXJyb3IiLCJ2YWxpZGF0ZSIsImV4ZWN1dGUiLCJwYXJzZSIsInNwZWNpZmllZFJ1bGVzIiwiT3BlcmF0aW9uRGVmaW5pdGlvbiIsIkZpZWxkIiwiZ2V0QXJndW1lbnRWYWx1ZXMiLCJzdWJzY3JpcHRpb25IYXNTaW5nbGVSb290RmllbGQiLCJTdWJzY3JpcHRpb25NYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwicHVic3ViIiwic2NoZW1hIiwic2V0dXBGdW5jdGlvbnMiLCJzdWJzY3JpcHRpb25zIiwibWF4U3Vic2NyaXB0aW9uSWQiLCJwdWJsaXNoIiwidHJpZ2dlck5hbWUiLCJwYXlsb2FkIiwic3Vic2NyaWJlIiwicGFyc2VkUXVlcnkiLCJxdWVyeSIsImVycm9ycyIsImxlbmd0aCIsIlByb21pc2UiLCJyZWplY3QiLCJudW1iZXIiLCJWYWxpZGF0aW9uRXJyb3IiLCJhcmdzIiwic3Vic2NyaXB0aW9uTmFtZSIsImRlZmluaXRpb25zIiwiZm9yRWFjaCIsImRlZmluaXRpb24iLCJraW5kIiwicm9vdEZpZWxkIiwic2VsZWN0aW9uU2V0Iiwic2VsZWN0aW9ucyIsIm5hbWUiLCJ2YWx1ZSIsImZpZWxkcyIsImdldFN1YnNjcmlwdGlvblR5cGUiLCJnZXRGaWVsZHMiLCJ2YXJpYWJsZXMiLCJ0cmlnZ2VyTWFwIiwiZXh0ZXJuYWxTdWJzY3JpcHRpb25JZCIsInN1YnNjcmlwdGlvblByb21pc2VzIiwiT2JqZWN0Iiwia2V5cyIsImNoYW5uZWxPcHRpb25zIiwiZmlsdGVyIiwib25NZXNzYWdlIiwicm9vdFZhbHVlIiwicmVzb2x2ZSIsInRoZW4iLCJjb250ZXh0IiwiYWxsIiwiZG9FeGVjdXRlIiwib3BlcmF0aW9uTmFtZSIsImRhdGEiLCJjYWxsYmFjayIsImNhdGNoIiwiZXJyb3IiLCJwdXNoIiwiaWQiLCJ1bnN1YnNj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QkFBN0MsQ0FBUDtBQUNBOztBQUVEb0IsYUFBWUMsS0FBWixFQUFrQjtBQUNqQjtBQUNBLE9BQUtuRCxhQUFMLENBQW1CbUQsS0FBbkIsRUFBMEJsQyxPQUExQixDQUFtQ21DLGNBQWM7QUFDaEQsUUFBS3ZELE1BQUwsQ0FBWXFELFdBQVosQ0FBd0JFLFVBQXhCO0FBQ0EsR0FGRDtBQUdBLFNBQU8sS0FBS3BELGFBQUwsQ0FBbUJtRCxLQUFuQixDQUFQO0FBQ0E7QUFySHdCLENBc0h6Qjs7QUFFRCxlQUFlekQsbUJBQWYiLCJmaWxlIjoibWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cydcbmltcG9ydCB7XG5cdEdyYXBoUUxTY2hlbWEsXG5cdEdyYXBoUUxFcnJvcixcblx0dmFsaWRhdGUsXG5cdGV4ZWN1dGUsXG5cdHBhcnNlLFxuXHRzcGVjaWZpZWRSdWxlcyxcblx0T3BlcmF0aW9uRGVmaW5pdGlvbixcblx0RmllbGQsXG59IGZyb20gJ2dyYXBocWwnXG5pbXBvcnQgeyBnZXRBcmd1bWVudFZhbHVlcyB9IGZyb20gJ2dyYXBocWwvZXhlY3V0aW9uL3ZhbHVlcydcblxuaW1wb3J0IHtcblx0c3Vic2NyaXB0aW9uSGFzU2luZ2xlUm9vdEZpZWxkLFxufSBmcm9tICcuL3ZhbGlkYXRpb24nXG5cblxuY2xhc3MgU3Vic2NyaXB0aW9uTWFuYWdlciB7XG5cdFxuXHRjb25zdHJ1Y3RvcihvcHRpb25zKXtcblx0XHR0aGlzLnB1YnN1YiA9IG9wdGlvbnMucHVic3ViO1xuXHRcdHRoaXMuc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG5cdFx0dGhpcy5zZXR1cEZ1bmN0aW9ucyA9IG9wdGlvbnMuc2V0dXBGdW5jdGlvbnMgfHwge307XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0ge307XG5cdFx0dGhpcy5tYXhTdWJzY3JpcHRpb25JZCA9IDA7XG5cdH1cblxuXHRwdWJsaXNoKHRyaWdnZXJOYW1lLCBwYXlsb2FkKXtcblx0XHR0aGlzLnB1YnN1Yi5wdWJsaXNoKHRyaWdnZXJOYW1lLCBwYXlsb2FkKTtcblx0fVxuXG5cdHN1YnNjcmliZShvcHRpb25zKXtcblxuXHRcdC8vIDEuIHZhbGlkYXRlIHRoZSBxdWVyeSwgb3BlcmF0aW9uTmFtZSBhbmQgdmFyaWFibGVzXG5cdFx0Y29uc3QgcGFyc2VkUXVlcnkgPSBwYXJzZShvcHRpb25zLnF1ZXJ5KTtcblx0XHRjb25zdCBlcnJvcnMgPSB2YWxpZGF0ZShcblx0XHRcdHRoaXMuc2NoZW1hLFxuXHRcdFx0cGFyc2VkUXVlcnksXG5cdFx0XHRbLi4uc3BlY2lmaWVkUnVsZXMsIHN1YnNjcmlwdGlvbkhhc1NpbmdsZVJvb3RGaWVsZF1cblx0XHQpO1xuXG5cdFx0Ly8gVE9ETzogdmFsaWRhdGUgdGhhdCBhbGwgdmFyaWFibGVzIGhhdmUgYmVlbiBwYXNzZWQgKGFuZCBhcmUgb2YgY29ycmVjdCB0eXBlKT9cblx0XHRpZiAoZXJyb3JzLmxlbmd0aCl7XG5cdFx0XHQvLyB0aGlzIGVycm9yIGtpbGxzIHRoZSBzdWJzY3JpcHRpb24sIHNvIHdlIHRocm93IGl0LlxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0PG51bWJlcj4obmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMpKTtcblx0XHR9XG5cblx0XHRsZXQgYXJncyA9IHt9O1xuXG5cdFx0Ly8gb3BlcmF0aW9uTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgb25seSByb290IGZpZWxkIGluIHRoZSBzdWJzY3JpcHRpb24gZG9jdW1lbnRcblx0XHRsZXQgc3Vic2NyaXB0aW9uTmFtZSA9ICcnO1xuXHRcdHBhcnNlZFF1ZXJ5LmRlZmluaXRpb25zLmZvckVhY2goIGRlZmluaXRpb24gPT4ge1xuXHRcdFx0aWYgKGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKXtcblx0XHRcdFx0Ly8gb25seSBvbmUgcm9vdCBmaWVsZCBpcyBhbGxvd2VkIG9uIHN1YnNjcmlwdGlvbi4gTm8gZnJhZ21lbnRzIGZvciBub3cuXG5cdFx0XHRcdGNvbnN0IHJvb3RGaWVsZCA9IChkZWZpbml0aW9uKS5zZWxlY3Rpb25TZXQuc2VsZWN0aW9uc1swXTtcblx0XHRcdFx0c3Vic2NyaXB0aW9uTmFtZSA9IHJvb3RGaWVsZC5uYW1lLnZhbHVlO1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkcyA9IHRoaXMuc2NoZW1hLmdldFN1YnNjcmlwdGlvblR5cGUoKS5nZXRGaWVsZHMoKTtcblx0XHRcdFx0YXJncyA9IGdldEFyZ3VtZW50VmFsdWVzKGZpZWxkc1tzdWJzY3JpcHRpb25OYW1lXSwgcm9vdEZpZWxkLCBvcHRpb25zLnZhcmlhYmxlcyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRsZXQgdHJpZ2dlck1hcDtcblxuXHRcdGlmICh0aGlzLnNldHVwRnVuY3Rpb25zW3N1YnNjcmlwdGlvbk5hbWVdKSB7XG5cdFx0XHR0cmlnZ2VyTWFwID0gdGhpcy5zZXR1cEZ1bmN0aW9uc1tzdWJzY3JpcHRpb25OYW1lXShvcHRpb25zLCBhcmdzLCBzdWJzY3JpcHRpb25OYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgbm90IHByb3ZpZGVkLCB0aGUgdHJpZ2dlck5hbWUgd2lsbCBiZSB0aGUgc3Vic2NyaXB0aW9uTmFtZSwgVGhlIHRyaWdnZXIgd2lsbCBub3QgaGF2ZSBhbnlcblx0XHRcdC8vIG9wdGlvbnMgYW5kIHJlbHkgb24gZGVmYXVsdHMgdGhhdCBhcmUgc2V0IGxhdGVyLlxuXHRcdFx0dHJpZ2dlck1hcCA9IHtbc3Vic2NyaXB0aW9uTmFtZV06IHt9fTtcblx0XHR9XG5cblx0XHRjb25zdCBleHRlcm5hbFN1YnNjcmlwdGlvbklkID0gdGhpcy5tYXhTdWJzY3JpcHRpb25JZCsrO1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9uc1tleHRlcm5hbFN1YnNjcmlwdGlvbklkXSA9IFtdO1xuXHRcdGNvbnN0IHN1YnNjcmlwdGlvblByb21pc2VzID0gW107XG5cdFx0T2JqZWN0LmtleXModHJpZ2dlck1hcCkuZm9yRWFjaCggdHJpZ2dlck5hbWUgPT4ge1xuXHRcdFx0Ly8gRGVjb25zdHJ1Y3QgdGhlIHRyaWdnZXIgb3B0aW9ucyBhbmQgc2V0IGFueSBkZWZhdWx0c1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRjaGFubmVsT3B0aW9ucyA9IHt9LFxuXHRcdFx0XHRmaWx0ZXIgPSAoKSA9PiB0cnVlLCAvLyBMZXQgYWxsIG1lc3NhZ2VzIHRocm91Z2ggYnkgZGVmYXVsdC5cblx0XHRcdH0gPSB0cmlnZ2VyTWFwW3RyaWdnZXJOYW1lXTtcblxuXHRcdFx0Ly8gMi4gZ2VuZXJhdGUgdGhlIGhhbmRsZXIgZnVuY3Rpb25cblx0XHRcdC8vXG5cdFx0XHQvLyByb290VmFsdWUgaXMgdGhlIHBheWxvYWQgc2VudCBieSB0aGUgZXZlbnQgZW1pdHRlciAvIHRyaWdnZXIgYnlcblx0XHRcdC8vIGNvbnZlbnRpb24gdGhpcyBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgbXV0YXRpb25cblx0XHRcdC8vIHJlc29sdmVyXG5cdFx0XHRjb25zdCBvbk1lc3NhZ2UgPSAocm9vdFZhbHVlKSA9PiB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdGlvbnMuY29udGV4dCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gb3B0aW9ucy5jb250ZXh0O1xuXHRcdFx0XHR9KS50aGVuKChjb250ZXh0KSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFtcblx0XHRcdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdFx0XHRmaWx0ZXIocm9vdFZhbHVlLCBjb250ZXh0KSxcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSkudGhlbigoW2NvbnRleHQsIGRvRXhlY3V0ZV0pID0+IHtcblx0XHRcdFx0ICBpZiAoIWRvRXhlY3V0ZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdCAgZXhlY3V0ZShcblx0XHRcdFx0XHQgIHRoaXMuc2NoZW1hLFxuXHRcdFx0XHRcdCAgcGFyc2VkUXVlcnksXG5cdFx0XHRcdFx0ICByb290VmFsdWUsXG5cdFx0XHRcdFx0ICBjb250ZXh0LFxuXHRcdFx0XHRcdCAgb3B0aW9ucy52YXJpYWJsZXMsXG5cdFx0XHRcdFx0ICBvcHRpb25zLm9wZXJhdGlvbk5hbWVcblx0XHRcdFx0ICApLnRoZW4oIGRhdGEgPT4ge1xuXHRcdFx0XHRcdCByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhkYXRhLmVycm9ycywgZGF0YSk7XG5cdFx0XHRcdCAgfSk7XG5cdFx0XHRcdH0pLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHRcdG9wdGlvbnMuY2FsbGJhY2soZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRcdC8vIDMuIHN1YnNjcmliZSBhbmQga2VlcCB0aGUgc3Vic2NyaXB0aW9uIGlkXG5cdFx0XHRzdWJzY3JpcHRpb25Qcm9taXNlcy5wdXNoKFxuXHRcdFx0XHR0aGlzLnB1YnN1Yi5zdWJzY3JpYmUodHJpZ2dlck5hbWUsIG9uTWVzc2FnZSwgY2hhbm5lbE9wdGlvbnMpXG5cdFx0XHRcdFx0LnRoZW4oaWQgPT4gdGhpcy5zdWJzY3JpcHRpb25zW2V4dGVybmFsU3Vic2NyaXB0aW9uSWRdLnB1c2goaWQpKVxuXHRcdFx0KTtcblx0XHR9KTtcblxuXHRcdC8vIFJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCBleHRlcm5hbCBzdWIgaWQgb25seSBhZnRlciBhbGwgc3Vic2NyaXB0aW9ucyBjb21wbGV0ZWRcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoc3Vic2NyaXB0aW9uUHJvbWlzZXMpLnRoZW4oKCkgPT4gZXh0ZXJuYWxTdWJzY3JpcHRpb25JZCk7XG5cdH1cblxuXHR1bnN1YnNjcmliZShzdWJJZCl7XG5cdFx0Ly8gcGFzcyB0aGUgc3ViSWQgcmlnaHQgdGhyb3VnaCB0byBwdWJzdWIuIERvIG5vdGhpbmcgZWxzZS5cblx0XHR0aGlzLnN1YnNjcmlwdGlvbnNbc3ViSWRdLmZvckVhY2goIGludGVybmFsSWQgPT4ge1xuXHRcdFx0dGhpcy5wdWJzdWIudW5zdWJzY3JpYmUoaW50ZXJuYWxJZCk7XG5cdFx0fSk7XG5cdFx0ZGVsZXRlIHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJJZF07XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmlwdGlvbk1hbmFnZXI7XG4iXX0=