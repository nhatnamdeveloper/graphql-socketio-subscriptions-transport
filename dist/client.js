'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _definitions = require('./definitions');

var _messageTypes = require('./messageTypes');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Client = function () {
	function Client(ref) {
		_classCallCheck(this, Client);

		this.ws = ref;
		this.subscriptions = {};
		this.maxId = 0;
		this.reconnectSubscriptions = {};
		this.unsentMessagesQueue = [];
		this.reconnecting = false;

		this.ws.on(_definitions.EVENT_KEY, this.handleMessage.bind(this));

		this.ws.on('connect', () => {
			this.sendUnsentMessages();
		});

		this.ws.on('reconnect_attempt', () => {
			if (!this.reconnecting) {
				this.reconnectSubscriptions = this.subscriptions;
				this.subscriptions = {};
				this.reconnecting = true;
			}
		});

		this.ws.on('reconnect', () => {
			this.reconnecting = false;

			Object.keys(this.reconnectSubscriptions).forEach(key => {
				var _reconnectSubscriptio = this.reconnectSubscriptions[key],
				    options = _reconnectSubscriptio.options,
				    handler = _reconnectSubscriptio.handler;


				this.subscribe(options, handler);
			});

			this.sendUnsentMessages();
		});
	}

	Client.prototype.handleMessage = function handleMessage({ id: id, type: type, payload: payload }) {
		switch (type) {
			case _messageTypes.SUBSCRIPTION_SUCCESS:
				this.subscriptions[id].pending = false;

				break;
			case _messageTypes.SUBSCRIPTION_FAIL:
				this.subscriptions[id].handler(this.formatErrors(payload.errors), null);
				delete this.subscriptions[id];

				break;
			case _messageTypes.SUBSCRIPTION_DATA:
				if (payload.data && !payload.errors) {
					this.subscriptions[id].handler(null, payload.data);
				} else {
					this.subscriptions[id].handler(this.formatErrors(payload.errors), null);
				}

				break;
			default:
				throw new Error('Invalid message type - must be of type `subscription_start` or `subscription_data`.');
		}
	};

	Client.prototype.formatErrors = function formatErrors(errors) {
		if (Array.isArray(errors)) {
			return errors;
		}
		if (errors && errors.message) {
			return [errors];
		}

		return [{ message: 'Unknown error' }];
	};

	Client.prototype.generateSubscriptionId = function generateSubscriptionId() {
		var id = this.maxId;
		this.maxId += 1;
		return id;
	};

	Client.prototype.sendUnsentMessages = function sendUnsentMessages() {
		this.unsentMessagesQueue.forEach(message => this.ws.emit(_definitions.EVENT_KEY, message));

		this.unsentMessagesQueue = [];
	};

	Client.prototype.sendMessage = function sendMessage(message) {
		switch (this.ws.io.readyState) {
			case 'opening':
				this.unsentMessagesQueue.push(message);

				break;
			case 'open':
				this.ws.emit(_definitions.EVENT_KEY, message);

				break;
			default:
				if (this.reconnecting) {
					this.unsentMessagesQueue.push(message);
				} else {
					throw new Error('Client is not connected to a websocket.');
				}

				break;
		}
	};

	Client.prototype.subscribe = function subscribe(options, handler) {
		var query = options.query,
		    variables = options.variables,
		    operationName = options.operationName,
		    context = options.context;


		if (!query) {
			throw new Error('Must provide `query` to subscribe.');
		}

		if (!handler) {
			throw new Error('Must provide `handler` to subscribe.');
		}

		if (typeof query !== 'string' || operationName && typeof operationName !== 'string' || variables && !(variables instanceof Object)) {
			throw new Error('Incorrect option types to subscribe. `subscription` must be a string,' + '`operationName` must be a string, and `variables` must be an object.');
		}

		var subId = this.generateSubscriptionId();

		var message = Object.assign(options, {
			type: _messageTypes.SUBSCRIPTION_START,
			id: subId
		});

		this.sendMessage(message);
		this.subscriptions[subId] = { options: options, handler: handler, pending: true };

		return subId;
	};

	Client.prototype.unsubscribe = function unsubscribe(id) {
		delete this.subscriptions[id];

		this.sendMessage({ id: id, type: _messageTypes.SUBSCRIPTION_END });
	};

	Client.prototype.unsubscribeAll = function unsubscribeAll() {
		Object.keys(this.subscriptions).forEach(subId => this.unsubscribe(parseInt(subId)));
	};

	return Client;
}();

exports.default = Client;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGllbnQuanMiXSwibmFtZXMiOlsiQ2xpZW50IiwicmVmIiwid3MiLCJzdWJzY3JpcHRpb25zIiwibWF4SWQiLCJyZWNvbm5lY3RTdWJzY3JpcHRpb25zIiwidW5zZW50TWVzc2FnZXNRdWV1ZSIsInJlY29ubmVjdGluZyIsIm9uIiwiaGFuZGxlTWVzc2FnZSIsImJpbmQiLCJzZW5kVW5zZW50TWVzc2FnZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm9wdGlvbnMiLCJoYW5kbGVyIiwic3Vic2NyaWJlIiwiaWQiLCJ0eXBlIiwicGF5bG9hZCIsInBlbmRpbmciLCJmb3JtYXRFcnJvcnMiLCJlcnJvcnMiLCJkYXRhIiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJtZXNzYWdlIiwiZ2VuZXJhdGVTdWJzY3JpcHRpb25JZCIsImVtaXQiLCJzZW5kTWVzc2FnZSIsImlvIiwicmVhZHlTdGF0ZSIsInB1c2giLCJxdWVyeSIsInZhcmlhYmxlcyIsIm9wZXJhdGlvbk5hbWUiLCJjb250ZXh0Iiwic3ViSWQiLCJhc3NpZ24iLCJ1bnN1YnNjcmliZSIsInVuc3Vic2NyaWJlQWxsIiwicGFyc2VJbnQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOzs7O0lBUXFCQSxNO0FBQ3BCLGlCQUFZQyxHQUFaLEVBQWlCO0FBQUE7O0FBQ2hCLE9BQUtDLEVBQUwsR0FBVUQsR0FBVjtBQUNBLE9BQUtFLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxPQUFLQyxLQUFMLEdBQWEsQ0FBYjtBQUNBLE9BQUtDLHNCQUFMLEdBQThCLEVBQTlCO0FBQ0EsT0FBS0MsbUJBQUwsR0FBMkIsRUFBM0I7QUFDQSxPQUFLQyxZQUFMLEdBQW9CLEtBQXBCOztBQUVBLE9BQUtMLEVBQUwsQ0FBUU0sRUFBUix5QkFBc0IsS0FBS0MsYUFBTCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBdEI7O0FBRUEsT0FBS1IsRUFBTCxDQUFRTSxFQUFSLENBQVcsU0FB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WCxFQUFvQkssU0FBUyxJQUE3QixFQUE1Qjs7QUFFQSxTQUFPa0IsS0FBUDtBQUNBLEU7O2tCQUVERSxXLHdCQUFZdkIsRSxFQUFJO0FBQ2YsU0FBTyxLQUFLaEIsYUFBTCxDQUFtQmdCLEVBQW5CLENBQVA7O0FBRUEsT0FBS2EsV0FBTCxDQUFpQixFQUFFYixNQUFGLEVBQU1DLG9DQUFOLEVBQWpCO0FBQ0EsRTs7a0JBRUR1QixjLDZCQUFpQjtBQUNoQi9CLFNBQU9DLElBQVAsQ0FBWSxLQUFLVixhQUFqQixFQUFnQ1csT0FBaEMsQ0FBd0MwQixTQUFTLEtBQUtFLFdBQUwsQ0FBaUJFLFNBQVNKLEtBQVQsQ0FBakIsQ0FBakQ7QUFDQSxFOzs7OztrQkFuSm1CeEMsTSIsImZpbGUiOiJjbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFVkVOVF9LRVkgfSBmcm9tICcuL2RlZmluaXRpb25zJ1xuXG5pbXBvcnQge1xuXHRTVUJTQ1JJUFRJT05fRkFJTCxcblx0U1VCU0NSSVBUSU9OX0RBVEEsXG5cdFNVQlNDUklQVElPTl9TVEFSVCxcblx0U1VCU0NSSVBUSU9OX1NVQ0NFU1MsXG5cdFNVQlNDUklQVElPTl9FTkRcbn0gZnJvbSAnLi9tZXNzYWdlVHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaWVudCB7XG5cdGNvbnN0cnVjdG9yKHJlZikge1xuXHRcdHRoaXMud3MgPSByZWZcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSB7fVxuXHRcdHRoaXMubWF4SWQgPSAwXG5cdFx0dGhpcy5yZWNvbm5lY3RTdWJzY3JpcHRpb25zID0ge31cblx0XHR0aGlzLnVuc2VudE1lc3NhZ2VzUXVldWUgPSBbXVxuXHRcdHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2VcblxuXHRcdHRoaXMud3Mub24oRVZFTlRfS0VZLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSlcblxuXHRcdHRoaXMud3Mub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNlbmRVbnNlbnRNZXNzYWdlcygpXG5cdFx0fSlcblxuXHRcdHRoaXMud3Mub24oJ3JlY29ubmVjdF9hdHRlbXB0JywgKCkgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLnJlY29ubmVjdGluZykge1xuXHRcdFx0XHR0aGlzLnJlY29ubmVjdFN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnNcblx0XHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zID0ge31cblx0XHRcdFx0dGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMud3Mub24oJ3JlY29ubmVjdCcsICgpID0+IHtcblx0XHRcdHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2VcblxuXHRcdFx0T2JqZWN0LmtleXModGhpcy5yZWNvbm5lY3RTdWJzY3JpcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdFx0Y29uc3QgeyBvcHRpb25zLCBoYW5kbGVyIH0gPSB0aGlzLnJlY29ubmVjdFN1YnNjcmlwdGlvbnNba2V5XVxuXG5cdFx0XHRcdHRoaXMuc3Vic2NyaWJlKG9wdGlvbnMsIGhhbmRsZXIpXG5cdFx0XHR9KVxuXG5cdFx0XHR0aGlzLnNlbmRVbnNlbnRNZXNzYWdlcygpXG5cdFx0fSlcblx0fVxuXG5cdGhhbmRsZU1lc3NhZ2UoeyBpZCwgdHlwZSwgcGF5bG9hZCB9KSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIFNVQlNDUklQVElPTl9TVUNDRVNTOlxuXHRcdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnNbaWRdLnBlbmRpbmcgPSBmYWxzZVxuXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIFNVQlNDUklQVElPTl9GQUlMOlxuXHRcdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnNbaWRdLmhhbmRsZXIodGhpcy5mb3JtYXRFcnJvcnMocGF5bG9hZC5lcnJvcnMpLCBudWxsKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5zdWJzY3JpcHRpb25zW2lkXVxuXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIFNVQlNDUklQVElPTl9EQVRBOlxuXHRcdFx0XHRpZiAocGF5bG9hZC5kYXRhICYmICFwYXlsb2FkLmVycm9ycykge1xuXHRcdFx0XHRcdHRoaXMuc3Vic2NyaXB0aW9uc1tpZF0uaGFuZGxlcihudWxsLCBwYXlsb2FkLmRhdGEpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zW2lkXS5oYW5kbGVyKHRoaXMuZm9ybWF0RXJyb3JzKHBheWxvYWQuZXJyb3JzKSwgbnVsbClcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZSB0eXBlIC0gbXVzdCBiZSBvZiB0eXBlIGBzdWJzY3JpcHRpb25fc3RhcnRgIG9yIGBzdWJzY3JpcHRpb25fZGF0YWAuJylcblx0XHR9XG5cdH1cblxuXHRmb3JtYXRFcnJvcnMoZXJyb3JzKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXJyb3JzKSkge1xuXHRcdFx0cmV0dXJuIGVycm9yc1xuXHRcdH1cblx0XHRpZiAoZXJyb3JzICYmIGVycm9ycy5tZXNzYWdlKSB7XG5cdFx0XHRyZXR1cm4gW2Vycm9yc11cblx0XHR9XG5cblx0XHRyZXR1cm4gW3sgbWVzc2FnZTogJ1Vua25vd24gZXJyb3InIH1dXG5cdH1cblxuXHRnZW5lcmF0ZVN1YnNjcmlwdGlvbklkKCkge1xuXHRcdGNvbnN0IGlkID0gdGhpcy5tYXhJZFxuXHRcdHRoaXMubWF4SWQgKz0gMVxuXHRcdHJldHVybiBpZFxuXHR9XG5cblx0c2VuZFVuc2VudE1lc3NhZ2VzKCkge1xuXHRcdHRoaXMudW5zZW50TWVzc2FnZXNRdWV1ZS5mb3JFYWNoKFxuXHRcdFx0bWVzc2FnZSA9PiB0aGlzLndzLmVtaXQoRVZFTlRfS0VZLCBtZXNzYWdlKVxuXHRcdClcblxuXHRcdHRoaXMudW5zZW50TWVzc2FnZXNRdWV1ZSA9IFtdXG5cdH1cblxuXHRzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0c3dpdGNoICh0aGlzLndzLmlvLnJlYWR5U3RhdGUpIHtcblx0XHRcdGNhc2UgJ29wZW5pbmcnOlxuXHRcdFx0XHR0aGlzLnVuc2VudE1lc3NhZ2VzUXVldWUucHVzaChtZXNzYWdlKVxuXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdvcGVuJzpcblx0XHRcdFx0dGhpcy53cy5lbWl0KEVWRU5UX0tFWSwgbWVzc2FnZSlcblxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aWYgKHRoaXMucmVjb25uZWN0aW5nKSB7XG5cdFx0XHRcdFx0dGhpcy51bnNlbnRNZXNzYWdlc1F1ZXVlLnB1c2gobWVzc2FnZSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBpcyBub3QgY29ubmVjdGVkIHRvIGEgd2Vic29ja2V0LicpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVha1xuXHRcdH1cblx0fVxuXG5cdHN1YnNjcmliZShvcHRpb25zLCBoYW5kbGVyKSB7XG5cdFx0Y29uc3QgeyBxdWVyeSwgdmFyaWFibGVzLCBvcGVyYXRpb25OYW1lLCBjb250ZXh0IH0gPSBvcHRpb25zXG5cblx0XHRpZiAoIXF1ZXJ5KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBgcXVlcnlgIHRvIHN1YnNjcmliZS4nKVxuXHRcdH1cblxuXHRcdGlmICghaGFuZGxlcikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYGhhbmRsZXJgIHRvIHN1YnNjcmliZS4nKVxuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCggdHlwZW9mIHF1ZXJ5ICE9PSAnc3RyaW5nJyApIHx8XG5cdFx0XHQoIG9wZXJhdGlvbk5hbWUgJiYgKHR5cGVvZiBvcGVyYXRpb25OYW1lICE9PSAnc3RyaW5nJykgKSB8fFxuXHRcdFx0KCB2YXJpYWJsZXMgJiYgISh2YXJpYWJsZXMgaW5zdGFuY2VvZiBPYmplY3QpIClcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG9wdGlvbiB0eXBlcyB0byBzdWJzY3JpYmUuIGBzdWJzY3JpcHRpb25gIG11c3QgYmUgYSBzdHJpbmcsJyArXG5cdFx0XHQnYG9wZXJhdGlvbk5hbWVgIG11c3QgYmUgYSBzdHJpbmcsIGFuZCBgdmFyaWFibGVzYCBtdXN0IGJlIGFuIG9iamVjdC4nKVxuXHRcdH1cblxuXHRcdGNvbnN0IHN1YklkID0gdGhpcy5nZW5lcmF0ZVN1YnNjcmlwdGlvbklkKClcblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcblx0XHRcdHR5cGU6IFNVQlNDUklQVElPTl9TVEFSVCxcblx0XHRcdGlkOiBzdWJJZFxuXHRcdH0pXG5cblx0XHR0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2UpXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zW3N1YklkXSA9IHsgb3B0aW9ucywgaGFuZGxlciwgcGVuZGluZzogdHJ1ZSB9XG5cblx0XHRyZXR1cm4gc3ViSWRcblx0fVxuXG5cdHVuc3Vic2NyaWJlKGlkKSB7XG5cdFx0ZGVsZXRlIHRoaXMuc3Vic2NyaXB0aW9uc1tpZF1cblxuXHRcdHRoaXMuc2VuZE1lc3NhZ2UoeyBpZCwgdHlwZTogU1VCU0NSSVBUSU9OX0VORCB9KVxuXHR9XG5cblx0dW5zdWJzY3JpYmVBbGwoKSB7XG5cdFx0T2JqZWN0LmtleXModGhpcy5zdWJzY3JpcHRpb25zKS5mb3JFYWNoKHN1YklkID0+IHRoaXMudW5zdWJzY3JpYmUocGFyc2VJbnQoc3ViSWQpKSlcblx0fVxufVxuIl19